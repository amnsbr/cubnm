<%
    import re
    import textwrap
    
    # Extract basic info
    name = model_name
    class_name = f"{name}SimGroup"
    
    # Extract parameter and state information from variables
    global_params = [v.name for v in variables.values() if v.var_type == 'global_param']
    regional_params = [v.name for v in variables.values() if v.var_type == 'regional_param']
    state_names = [v.name for v in variables.values() if v.var_type == 'state_var']
    sel_state_var = python_config.get('sel_state_var', state_names[0] if state_names else None)
    
    # Count noise variables
    n_noise = sum(1 for v in variables.values() if v.var_type == 'noise')
    
    # Extract global outputs from variables
    global_out_bools = [v.name.replace('_global', '') for v in variables.values() if v.var_type == 'global_out_bool']
    global_out_ints = [v.name.replace('_global', '') for v in variables.values() if v.var_type == 'global_out_int']
    global_out_floats = [v.name.replace('_global', '') for v in variables.values() if v.var_type == 'global_out_double']
    
    # Extract default parameters from variables
    defaults = {}
    for v in variables.values():
        if v.var_type in ['global_param', 'regional_param']:
            defaults[v.name] = v.value
    
    # Extract modifiable params
    modifiable_params = python_config.get('modifiable_params', [])
    
    # Parse configs - convert C++ configs to Python __init__ parameters
    init_configs = []
    for c in config:
        c_type, c_name, c_value, c_desc = c
        if c_name in python_config.get('exclude_configs', []):
            continue
        # Infer Python default from C++ value
        if c_type == 'bool':
            py_default = c_value.lower() in ['true', '1']
            py_type = 'bool'
        elif c_type == 'int':
            try:
                py_default = int(c_value)
            except ValueError:
                py_default = c_value
            py_type = 'int'
        elif c_type == 'double':
            try:
                py_default = float(c_value)
            except ValueError:
                py_default = c_value
            py_type = 'float'
        else:
            py_default = c_value
            py_type = 'str'
        
        init_configs.append({
            'name': c_name,
            'type': py_type,
            'default': py_default,
            'description': c_desc,
            'c_type': c_type,
            'c_value': c_value
        })
    
    # Extract custom methods
    custom_methods = python_config.get('custom_methods', {})
        
    # Get docstring components
    param_descriptions = {}
    for param in global_params + regional_params:
        for var in variables.values():
            if var.name == param:
                param_descriptions[var.name] = var.description
                break
    
    # Helper function to format parameter lists
    def format_param_dict(params_dict, indent=8):
        if not params_dict:
            return ""
        lines = []
        for key, val in params_dict.items():
            if val is None:
                lines.append(f'"{key}": None,  # required')
            else:
                lines.append(f'"{key}": {val},')
        return ('\n' + ' ' * indent).join(lines)
    
    # Determine which methods need to be generated
    needs_init = '__init__' not in custom_methods
    needs_get_config = 'get_config' not in custom_methods
    needs_model_config = '_model_config_getter' not in custom_methods
    needs_labels = 'labels_getter' not in custom_methods and python_config.get('labels')
    needs_process_out = '_process_out' not in custom_methods and (global_out_bools or global_out_ints or global_out_floats or modifiable_params)
    needs_get_save_data = '_get_save_data' not in custom_methods and (global_out_bools or global_out_ints or global_out_floats)
    needs_clear = '_to_clear_getter' not in custom_methods and (global_out_bools or global_out_ints or global_out_floats)
%>\
"""
Autogenerated using:
- Template: '${template_path}'
- Model definition: '${yaml_path}'
Do not modify this autogenerated code. Instead modify template
or model definition.
"""
from .base import SimGroup
import numpy as np
% for imp in python_config.get('imports', []):
${imp}
% endfor

class ${class_name}(SimGroup):
    model_name = "${name}"
    global_param_names = ${repr(global_params)}
    regional_param_names = ${repr(regional_params)}
    state_names = ${repr(state_names)}
% if sel_state_var:
    sel_state_var = "${sel_state_var}"
% endif
% if n_noise:
    n_noise = ${n_noise}
% endif
    default_params = {
        ${format_param_dict(defaults)}
    }
% if needs_init:
% if init_configs:

    def __init__(
        self, 
        *args,\
% for cfg in init_configs:
 
        ${cfg['name']} = ${repr(cfg['default'])},\
% endfor
 
        **kwargs
    ):
% else:

    def __init__(self, *args, **kwargs):
% endif
        """
        Group of ${full_name} simulations that are executed in parallel.

        Parameters
        ---------
% for cfg in init_configs:
        ${cfg['name']}: :obj:`${cfg['type']}`
            ${cfg.get('description', '')}
% endfor
        *args, **kwargs:
            see :class:`cubnm.sim.SimGroup` for details

        Attributes
        ----------
        param_lists: :obj:`dict` of :obj:`np.ndarray`
            dictionary of parameter lists, including
% for param in global_params:
                - ``'${param}'``: ${param_descriptions.get(param, '')}. Shape: (N_SIMS,)
% endfor
% for param in regional_params:
                - ``'${param}'``: ${param_descriptions.get(param, '')}. Shape: (N_SIMS, nodes)
% endfor
                - ``'v'``: conduction velocity. Shape: (N_SIMS,)
% if add_examples:

        Example
        -------
        To see example usage in grid search and evolutionary algorithms
        see :mod:`cubnm.optimize`.

        Here, as an example on how to use SimGroup independently, we
        will run a single simulation and save the outputs to disk. ::

            from cubnm import sim, datasets

            sim_group = sim.${class_name}(
                duration=60,
                TR=1,
                sc=datasets.load_sc('strength', 'schaefer-100'),
            )
            sim_group.N = 1
            sim_group.param_lists["${global_params[0] if global_params else 'G'}"] = np.array([0.5])  # set global coupling
            sim_group._set_default_params() # set other parameters to default
            sim_group.run()
% endif
% if citations:

        References
        ----------        
        % for citation in citations:
        * ${citation}
        % endfor
% endif
% if notes:

        Notes
        -----
        ${textwrap.indent(notes, '        ').strip()}
% endif
        """
% for cfg in init_configs:
        self.${cfg['name']} = ${cfg['name']}
% endfor
        # parent init must be called after setting
        # model-specific attributes because
        # it sets .last_config which may include some
        # model-specific attributes
        super().__init__(*args, **kwargs)
% endif
% if needs_get_config:
% if init_configs:

    def get_config(self, *args, **kwargs):
        config = super().get_config(*args, **kwargs)
        config.update({
% for cfg in init_configs:
            '${cfg['name']}': self.${cfg['name']},
% endfor
        })
        return config
% endif
% endif
% if needs_model_config:
% if init_configs:
    
    @property
    def _model_config(self):
        """
        Internal model configuration used in the simulation
        """
        model_config = super()._model_config
        model_config.update({
% for cfg in init_configs:
<%
    # Convert Python value to C++ string representation
    if cfg['c_type'] == 'bool':
        c_str_value = f"str(int(self.{cfg['name']}))"
    elif cfg['c_type'] in ['int', 'double']:
        c_str_value = f"str(self.{cfg['name']})"
    else:
        c_str_value = f"str(self.{cfg['name']})"
%>\
            '${cfg['name']}': ${c_str_value},
% endfor
        })
        return model_config
% endif
% endif
% if needs_labels:

    @property
    def labels(self):
        """
        Labels of parameters and state variables
        to use in plots and reports
        """
        labels = super().labels
        labels.update({
% for key, value in python_config['labels'].items():
            '${key}': r'${value}',
% endfor
        })
        return labels
% endif
% if needs_process_out:

    def _process_out(self, out):
        super()._process_out(out)
% if global_out_bools:
        # Extract global boolean outputs
% for idx, var_name in enumerate(global_out_bools):
        self.${var_name} = self._global_bools[${idx}]
% endfor
% endif
% if global_out_ints:
        # Extract global integer outputs
% for idx, var_name in enumerate(global_out_ints):
        self.${var_name} = self._global_ints[${idx}]
% endfor
% endif
% if global_out_floats:
        # Extract global float outputs
% for idx, var_name in enumerate(global_out_floats):
        self.${var_name} = self._global_floats[${idx}]
% endfor
% endif
% if modifiable_params:
        # Extract modifiable parameters
% for param in modifiable_params:
        self.param_lists["${param}"] = self._regional_params[${regional_params.index(param)}].reshape(self.N, -1)
% endfor
% endif
% endif
% if needs_get_save_data:
    
    def _get_save_data(self):
        """
        Get the simulation outputs and parameters to be saved to disk

        Returns
        -------
        out_data: :obj:`dict`
            dictionary of simulation outputs and parameters
        """
        out_data = super()._get_save_data()
        out_data.update({
% for var_name in global_out_bools + global_out_ints + global_out_floats:
            '${var_name}': self.${var_name},
% endfor
        })
        return out_data
% endif
% if needs_clear:
    
    @property
    def _to_clear(self):
        """
        List of attributes to be cleared when clear() is called
        """
        attrs = super()._to_clear + [
% for var_name in global_out_bools + global_out_ints + global_out_floats:
            "${var_name}",
% endfor
        ]
        return [attr for attr in attrs if hasattr(self, attr)]
% endif
% for method_name, method_code in custom_methods.items():
<%
    # Dedent to remove common leading whitespace
    dedented_code = textwrap.dedent(method_code).strip()
    # Add 4 spaces to each line for class method indentation
    indented_lines = ['    ' + line if line.strip() else line for line in dedented_code.split('\n')]
    final_code = '\n'.join(indented_lines)
%>\

${final_code}
% endfor
