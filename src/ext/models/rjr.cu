/* 
    Autogenerated using:
    - Template: 'src/ext/models/model.cu.mako'
    - Model definition: 'codegen/recipes/rjr.yaml'
    Do not modify this autogenerated code. Instead modify template
    or model definition.
*/
#include "cubnm/includes.cuh"
#include "cubnm/defines.h"
#include "cubnm/models/rjr.cuh"

__device__ __NOINLINE__ void rJRModel::init(
    double* _state_vars, double* _intermediate_vars,
    double* _global_params, double* _regional_params,
    int* _ext_int, bool* _ext_bool,
    int* _ext_int_shared, bool* _ext_bool_shared
) {
    // EPSP = V0
    _state_vars[0] = d_rJRc.V0;
    // IPSP = V0
    _state_vars[1] = d_rJRc.V0;
    // EPSC = 0.0
    _state_vars[2] = 0.0;
    // IPSC = 0.0
    _state_vars[3] = 0.0;
    // normEPSP = V0
    _state_vars[4] = d_rJRc.V0;
}

__device__ __NOINLINE__ void rJRModel::restart(
    double* _state_vars, double* _intermediate_vars, 
    double* _global_params, double* _regional_params,
    int* _ext_int, bool* _ext_bool,
    int* _ext_int_shared, bool* _ext_bool_shared
) {
    // EPSP = V0
    _state_vars[0] = d_rJRc.V0;
    // IPSP = V0
    _state_vars[1] = d_rJRc.V0;
    // EPSC = 0.0
    _state_vars[2] = 0.0;
    // IPSC = 0.0
    _state_vars[3] = 0.0;
    // normEPSP = V0
    _state_vars[4] = d_rJRc.V0;
}

__device__ void rJRModel::step(
        double* _state_vars, double* _intermediate_vars,
        double* _global_params, double* _regional_params,
        double& tmp_globalinput,
        double* noise, long& noise_idx
        ) {
    // Second derivative of EPSP
    // d2EPSP_dt2 = (HeKe * pow(R, 2) * (Fe / (1.0 + exp(Re * (V50e - (G * globalinput - C_EI * IPSP)))))) - DrKe2 * R * EPSC - Ke_sq * pow(R, 2) * EPSP
    _intermediate_vars[0] = (d_rJRc.HeKe * pow(_regional_params[2], 2) * (d_rJRc.Fe / (1.0 + exp(d_rJRc.Re * (d_rJRc.V50e - (_global_params[0] * tmp_globalinput - _regional_params[0] * _state_vars[1])))))) - d_rJRc.DrKe2 * _regional_params[2] * _state_vars[2] - d_rJRc.Ke_sq * pow(_regional_params[2], 2) * _state_vars[0];
    // Second derivative of IPSP
    // d2IPSP_dt2 = (HiKi * pow(R, 2) * (Fi / (1.0 + exp(Ri * (V50i - (C_IE * EPSP)))))) - DrKi2 * R * IPSC - Ki_sq * pow(R, 2) * IPSP
    _intermediate_vars[1] = (d_rJRc.HiKi * pow(_regional_params[2], 2) * (d_rJRc.Fi / (1.0 + exp(d_rJRc.Ri * (d_rJRc.V50i - (_regional_params[1] * _state_vars[0])))))) - d_rJRc.DrKi2 * _regional_params[2] * _state_vars[3] - d_rJRc.Ki_sq * pow(_regional_params[2], 2) * _state_vars[1];
    // EPSP = EPSP + dEPSP/dt*dt where dEPSP/dt = EPSC (from the previous time point)
    // EPSP += EPSC * dt
    _state_vars[0] += _state_vars[2] * d_rJRc.dt;
    // IPSP = IPSP + dIPSP/dt*dt where dIPSP/dt = IPSC (from the previous time point)
    // IPSP += IPSC * dt
    _state_vars[1] += _state_vars[3] * d_rJRc.dt;
    // Update EPSC using second derivative
    // EPSC += d2EPSP_dt2 * dt
    _state_vars[2] += _intermediate_vars[0] * d_rJRc.dt;
    // Update IPSC using second derivative
    // IPSC += d2IPSP_dt2 * dt
    _state_vars[3] += _intermediate_vars[1] * d_rJRc.dt;
    // Add noise to EPSC
    // EPSC += sqrt_dt * sigma * pow(R, 2) * noise
    _state_vars[2] += d_rJRc.sqrt_dt * _regional_params[3] * pow(_regional_params[2], 2) * noise[noise_idx];
    // Add noise to IPSC
    // IPSC += sqrt_dt * sigma * pow(R, 2) * noise
    _state_vars[3] += d_rJRc.sqrt_dt * _regional_params[3] * pow(_regional_params[2], 2) * noise[noise_idx];
    // Calculate normalized EPSP for BOLD
    // normEPSP = EPSP / He
    _state_vars[4] = _state_vars[0] / d_rJRc.He;
}
