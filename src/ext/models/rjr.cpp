/* 
    Autogenerated using:
    - Template: 'src/ext/models/model.cpp.mako'
    - Model definition: 'codegen/recipes/rjr.yaml'
    Do not modify this autogenerated code. Instead modify template
    or model definition.
*/
#include "cubnm/models/rjr.hpp"

// Static constants instance
rJRModel::Constants rJRModel::mc;

// Initialize constants based on dt
void rJRModel::init_constants(double dt) {
    mc.dt = dt * 0.001; // integration step (seconds)
    mc.sqrt_dt = sqrt(mc.dt); // square root of integration step
    mc.Ke = 100.0; // inversion of time constant of the EPSP kernel (1/sec)
    mc.Ki = 50.0; // inversion of time constant of the IPSP kernel (1/sec)
    mc.He = 3.25; // maximal EPSP (mV)
    mc.Hi = 22.0; // maximal IPSP (mV)
    mc.Fe = 100.0; // maximal firing rate of excitatory population (Hz)
    mc.Fi = 50.0; // maximal firing rate of inhibitory population (Hz)
    mc.Re = 0.56; // slope of the sigmoid activation function for excitatory population (1/mV)
    mc.Ri = 0.56; // slope of the sigmoid activation function for inhibitory population (1/mV)
    mc.V50e = 6.0; // EPSP that achieves a 50% firing rate of a neural population (mV)
    mc.V50i = 6.0; // IPSP that achieves a 50% firing rate of a neural population (mV)
    mc.Dr = 1.0; // damping ratio = 1 for critical damping (Dr > 1 exponential decaying, Dr < 1 oscillating)
    mc.V0 = 0.0; // rest potential (mV) for PSP
    mc.HeKe = mc.He * mc.Ke; // He * Ke
    mc.HiKi = mc.Hi * mc.Ki; // Hi * Ki
    mc.DrKe2 = mc.Dr * mc.Ke * 2; // Dr * Ke^2
    mc.DrKi2 = mc.Dr * mc.Ki * 2; // Dr * Ki^2
    mc.Ke_sq = mc.Ke * mc.Ke; // Ke squared
    mc.Ki_sq = mc.Ki * mc.Ki; // Ki squared
}
void rJRModel::set_conf(std::map<std::string, std::string> config_map) {
    set_base_conf(config_map);
    for (const auto& pair : config_map) {
        if (pair.first == "R_mean") {
            this->conf.R_mean = std::stod(pair.second);
        }        else if (pair.first == "R_range") {
            this->conf.R_range = std::stod(pair.second);
        }        else if (pair.first == "R_dist_uniform") {
            this->conf.R_dist_uniform = (bool)std::stoi(pair.second);
        }
    }
}

void rJRModel::h_init(
    double* _state_vars, double* _intermediate_vars,
    double* _global_params, double* _regional_params,
    int* _ext_int, bool* _ext_bool,
    int* _ext_int_shared, bool* _ext_bool_shared
) {
    // EPSP = V0
    _state_vars[0] = rJRModel::mc.V0;
    // IPSP = V0
    _state_vars[1] = rJRModel::mc.V0;
    // EPSC = 0.0
    _state_vars[2] = 0.0;
    // IPSC = 0.0
    _state_vars[3] = 0.0;
    // normEPSP = V0
    _state_vars[4] = rJRModel::mc.V0;
}

void rJRModel::_j_restart(
    double* _state_vars, double* _intermediate_vars, 
    double* _global_params, double* _regional_params,
    int* _ext_int, bool* _ext_bool,
    int* _ext_int_shared, bool* _ext_bool_shared
) {
    // EPSP = V0
    _state_vars[0] = rJRModel::mc.V0;
    // IPSP = V0
    _state_vars[1] = rJRModel::mc.V0;
    // EPSC = 0.0
    _state_vars[2] = 0.0;
    // IPSC = 0.0
    _state_vars[3] = 0.0;
    // normEPSP = V0
    _state_vars[4] = rJRModel::mc.V0;
}

void rJRModel::h_step(
        double* _state_vars, double* _intermediate_vars,
        double* _global_params, double* _regional_params,
        double& tmp_globalinput,
        double* noise, long& noise_idx
        ) {
    // Second derivative of EPSP
    // d2EPSP_dt2 = (HeKe * pow(R, 2) * (Fe / (1.0 + exp(Re * (V50e - (G * globalinput - c_EI * IPSP)))))) - DrKe2 * R * EPSC - Ke_sq * pow(R, 2) * EPSP
    _intermediate_vars[0] = (rJRModel::mc.HeKe * pow(_regional_params[2], 2) * (rJRModel::mc.Fe / (1.0 + exp(rJRModel::mc.Re * (rJRModel::mc.V50e - (_global_params[0] * tmp_globalinput - c_EI * _state_vars[1])))))) - rJRModel::mc.DrKe2 * _regional_params[2] * _state_vars[2] - rJRModel::mc.Ke_sq * pow(_regional_params[2], 2) * _state_vars[0];
    // Second derivative of IPSP
    // d2IPSP_dt2 = (HiKi * pow(R, 2) * (Fi / (1.0 + exp(Ri * (V50i - (C_IE * EPSP)))))) - DrKi2 * R * IPSC - Ki_sq * pow(R, 2) * IPSP
    _intermediate_vars[1] = (rJRModel::mc.HiKi * pow(_regional_params[2], 2) * (rJRModel::mc.Fi / (1.0 + exp(rJRModel::mc.Ri * (rJRModel::mc.V50i - (_regional_params[1] * _state_vars[0])))))) - rJRModel::mc.DrKi2 * _regional_params[2] * _state_vars[3] - rJRModel::mc.Ki_sq * pow(_regional_params[2], 2) * _state_vars[1];
    // EPSP = EPSP + dEPSP/dt*dt where dEPSP/dt = EPSC (from the previous time point)
    // EPSP += EPSC * dt
    _state_vars[0] += _state_vars[2] * rJRModel::mc.dt;
    // IPSP = IPSP + dIPSP/dt*dt where dIPSP/dt = IPSC (from the previous time point)
    // IPSP += IPSC * dt
    _state_vars[1] += _state_vars[3] * rJRModel::mc.dt;
    // Update EPSC using second derivative
    // EPSC += d2EPSP_dt2 * dt
    _state_vars[2] += _intermediate_vars[0] * rJRModel::mc.dt;
    // Update IPSC using second derivative
    // IPSC += d2IPSP_dt2 * dt
    _state_vars[3] += _intermediate_vars[1] * rJRModel::mc.dt;
    // Add noise to EPSC
    // EPSC += sqrt_dt * sigma * pow(R, 2) * noise
    _state_vars[2] += rJRModel::mc.sqrt_dt * _regional_params[3] * pow(_regional_params[2], 2) * noise[noise_idx];
    // Add noise to IPSC
    // IPSC += sqrt_dt * sigma * pow(R, 2) * noise
    _state_vars[3] += rJRModel::mc.sqrt_dt * _regional_params[3] * pow(_regional_params[2], 2) * noise[noise_idx];
    // Calculate normalized EPSP for BOLD
    // normEPSP = EPSP / He
    _state_vars[4] = _state_vars[0] / rJRModel::mc.He;
}
