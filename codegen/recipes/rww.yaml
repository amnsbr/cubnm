model_name: rWW
full_name: reduced Wong-Wang (excitatory-inhibitory)
citations:
  - Deco et al. 2014 Journal of Neuroscience (10.1523/JNEUROSCI.5068-13.2014) # main model equations + numerical FIC
  - Demirtas et al. 2019 Neuron (10.1016/j.neuron.2019.01.017) # analytical FIC
  - Deco et al. 2018 Current Biology (10.1016/j.cub.2018.07.083) # part of implementation

init_equations: |
  S_E = 0.001
  S_I = 0.001
  # Numerical FIC initialization
  mean_I_E = 0.0
  delta = init_delta
  fic_trial = 0
  _adjust_fic = do_fic & (max_fic_trials > 0)
  fic_failed = false

restart_equations: |
  S_E = 0.001
  S_I = 0.001
  # Numerical FIC reset
  mean_I_E = 0.0

step_equations: |
  # Calculate input currents
  I_E = w_E__I_0 + w_p * J_N * S_E + globalinput * G * J_N - wIE * S_I
  I_I = w_I__I_0 + J_N * S_E - w_II * S_I
  
  # Input-output functions
  aIb_E = a_E * I_E - b_E
  aIb_I = a_I * I_I - b_I
  r_E = aIb_E / (1 - exp(-d_E * aIb_E))
  r_I = aIb_I / (1 - exp(-d_I * aIb_I))
  
  # Synaptic dynamics with noise
  dS_E = noise_S_E * sigma * sqrt_dt + dt_gamma_E * ((1 - S_E) * r_E) - dt_itau_E * S_E
  dS_I = noise_S_I * sigma * sqrt_dt + dt_gamma_I * r_I - dt_itau_I * S_I
  
  S_E += dS_E
  S_I += dS_I
  
  # Clip to valid range
  S_E = max(0.0, min(1.0, S_E))
  S_I = max(0.0, min(1.0, S_I))

conn_state_var: S_E
is_osc: false

bold_state_var: S_E

variables:
  - name: I_E
    type: state_var
    description: excitatory input current
    
  - name: I_I
    type: state_var
    description: inhibitory input current
    
  - name: r_E
    type: state_var
    description: excitatory firing rate
    
  - name: r_I
    type: state_var
    description: inhibitory firing rate
    
  - name: S_E
    type: state_var
    description: excitatory synaptic gating variable
    
  - name: S_I
    type: state_var
    description: inhibitory synaptic gating variable
    
  - name: aIb_E
    type: intermediate_var
    description: a_E * I_E - b_E
    
  - name: aIb_I
    type: intermediate_var
    description: a_I * I_I - b_I
    
  - name: dS_E
    type: intermediate_var
    description: S_E update
    
  - name: dS_I
    type: intermediate_var
    description: S_I update
    
  - name: mean_I_E
    type: intermediate_var
    description: mean excitatory input for FIC
    
  - name: delta
    type: intermediate_var
    description: FIC adjustment step size
    
  - name: I_E_ba_diff
    type: intermediate_var
    description: difference from target for FIC
    
  - name: G
    type: global_param
    description: global coupling strength
    # has no default
    
  - name: w_p
    type: regional_param
    description: local excitatory recurrence
    value: 1.4
    
  - name: J_N
    type: regional_param
    description: synaptic coupling strength
    value: 0.15
    
  - name: wIE
    type: regional_param
    description: inhibitory to excitatory weight
    value: 1.0
    
  - name: sigma
    type: regional_param
    description: noise amplitude
    value: 0.01
    
  - name: noise_S_E
    type: noise
    description: noise for S_E

  - name: noise_S_I
    type: noise
    description: noise for S_I

  - name: _adjust_fic
    type: ext_bool_shared
    description: whether to adjust FIC

  - name: fic_failed
    type: ext_bool_shared
    description: FIC failure flag

  - name: fic_trial
    type: ext_int_shared
    description: current FIC trial number

  - name: fic_unstable_global
    type: global_out_bool
    description: FIC unstability flag
  
  - name: fic_failed_global
    type: global_out_bool
    description: FIC failure flag (output)
  
  - name: fic_ntrials_global
    type: global_out_int
    description: number of attempted FIC trials

constants:
  - type: double
    name: dt
    value: dt
    description: integration step
    
  - type: double
    name: sqrt_dt
    value: sqrt(mc.dt)
    description: square root of integration step
    
  - type: double
    name: a_E
    value: "310"
    description: excitatory input-output parameter a (n/C)
    
  - type: double
    name: b_E
    value: "125"
    description: excitatory input-output parameter b (Hz)
    
  - type: double
    name: d_E
    value: "0.16"
    description: excitatory input-output parameter d (s)
    
  - type: double
    name: a_I
    value: "615"
    description: inhibitory input-output parameter a (n/C)
    
  - type: double
    name: b_I
    value: "177"
    description: inhibitory input-output parameter b (Hz)
    
  - type: double
    name: d_I
    value: "0.087"
    description: inhibitory input-output parameter d (s)
    
  - type: double
    name: gamma_E
    value: "(double)0.641/(double)1000.0"
    description: excitatory kinetic parameter
    
  - type: double
    name: gamma_I
    value: "(double)1.0/(double)1000.0"
    description: inhibitory kinetic parameter
    
  - type: double
    name: tau_E
    value: "100"
    description: NMDA time constant (ms)
    
  - type: double
    name: tau_I
    value: "10"
    description: GABA time constant (ms)
    
  - type: double
    name: I_0
    value: "0.382"
    description: overall effective external input (nA)
    
  - type: double
    name: w_E
    value: "1.0"
    description: scaling of external input for excitatory pool
    
  - type: double
    name: w_I
    value: "0.7"
    description: scaling of external input for inhibitory pool
    
  - type: double
    name: w_II
    value: "1.0"
    description: inhibitory self-coupling
    
  - type: double
    name: I_ext
    value: "0.0"
    description: external input (nA)
    
  - type: double
    name: w_E__I_0
    value: mc.w_E * mc.I_0
    description: pre-calculated w_E * I_0
    
  - type: double
    name: w_I__I_0
    value: mc.w_I * mc.I_0
    description: pre-calculated w_I * I_0
    
  - type: double
    name: b_a_ratio_E
    value: mc.b_E / mc.a_E
    description: pre-calculated b_E / a_E
    
  - type: double
    name: itau_E
    value: 1.0/mc.tau_E
    description: inverse of tau_E
    
  - type: double
    name: itau_I
    value: 1.0/mc.tau_I
    description: inverse of tau_I
    
  - type: double
    name: dt_itau_E
    value: mc.dt * mc.itau_E
    description: dt / tau_E
    
  - type: double
    name: dt_gamma_E
    value: mc.dt * mc.gamma_E
    description: dt * gamma_E
    
  - type: double
    name: dt_itau_I
    value: mc.dt * mc.itau_I
    description: dt / tau_I
    
  - type: double
    name: dt_gamma_I
    value: mc.dt * mc.gamma_I
    description: dt * gamma_I
    
  - type: double
    name: tau_E_s
    value: "0.1"
    description: tau_E in seconds for FIC
    
  - type: double
    name: tau_I_s
    value: "0.01"
    description: tau_I in seconds for FIC
    
  - type: double
    name: gamma_E_s
    value: "0.641"
    description: gamma_E for FIC
    
  - type: double
    name: gamma_I_s
    value: "1.0"
    description: gamma_I for FIC
    
  - type: double
    name: r_I_ss
    value: "3.9218448633"
    description: steady-state inhibitory firing rate (Hz)
    
  - type: double
    name: r_E_ss
    value: "3.0773270642"
    description: steady-state excitatory firing rate (Hz)
    
  - type: double
    name: I_I_ss
    value: "0.2528951325"
    description: steady-state inhibitory current (nA)
    
  - type: double
    name: I_E_ss
    value: "0.3773805650"
    description: steady-state excitatory current (nA)
    
  - type: double
    name: S_I_ss
    value: "0.0392184486"
    description: steady-state inhibitory gating
    
  - type: double
    name: S_E_ss
    value: "0.1647572075"
    description: steady-state excitatory gating

config:
  - type: bool
    name: do_fic
    value: "true"
    description: whether to apply feedback inhibition control. If provided wIE parameters will be ignored

  - type: int
    name: max_fic_trials
    value: 0
    description: maximum number of numerical FIC trials. If set to 0, FIC will be done only analytically
    
  - type: int
    name: I_SAMPLING_START
    value: 1000
    description: starting time of numerical FIC I_E sampling (msec)
  
  - type: int
    name: I_SAMPLING_END
    value: 10000
    description: end time of numerical FIC I_E sampling (msec)
  
  - type: int
    name: I_SAMPLING_DURATION
    value: "I_SAMPLING_END - I_SAMPLING_START + 1"
    description: duration of numerical FIC I_E sampliing (bw iterations)

  - type: double
    name: init_delta
    value: 0.02
    description: initial delta for numerical FIC adjustment

  - type: double # only used in Python code
    name: fic_penalty_scale
    value: 0.5
    description: how much deviation from FIC target mean rE of 3 Hz is penalized. Set to 0 to disable FIC penalty.

# Advanced C++/CUDA specificaitons
has_prep_params: true
has_post_bw_step: true
has_post_integration: true

external_declarations: |
  extern void analytical_fic_het(
          gsl_matrix * sc, double G, double * w_EE, double * w_EI,
          gsl_vector * w_IE_out, bool * _unstable
          );

# Include helper functions from external file
cpp_includes: |
  #include "rww_fic.cpp"

# Custom implementations for special methods
custom_methods:
  set_conf: |
    void rWWModel::set_conf(std::map<std::string, std::string> config_map) {
        set_base_conf(config_map);
        for (const auto& pair : config_map) {
            if (pair.first == "do_fic") {
                this->conf.do_fic = (bool)std::stoi(pair.second);
                this->modifies_params = true;
            } else if (pair.first == "max_fic_trials") {
                this->conf.max_fic_trials = std::stoi(pair.second);
            } else if (pair.first == "I_SAMPLING_START") {
                this->conf.I_SAMPLING_START = (std::stoi(pair.second) / 1000) / this->bw_dt;
            } else if (pair.first == "I_SAMPLING_END") {
                this->conf.I_SAMPLING_END = (std::stoi(pair.second) / 1000) / this->bw_dt;
            } else if (pair.first == "init_delta") {
                this->conf.init_delta = std::stod(pair.second);
            }
            this->conf.I_SAMPLING_DURATION = this->conf.I_SAMPLING_END - this->conf.I_SAMPLING_START + 1;
        }
    }

  prep_params: |
    void rWWModel::prep_params(
            double ** global_params, double ** regional_params, double * v_list,
            double ** SC, int * SC_indices, double * SC_dist,
            bool ** global_out_bool, int ** global_out_int
            ) {
        // Set wIE to output of analytical FIC
        // if FIC is enabled
        if (!(this->conf.do_fic)) {
            return;
        }
        // copy SC to SCs_gsl
        std::vector<gsl_matrix*> SCs_gsl;
        #ifdef OMP_ENABLED
        #pragma omp critical
        #endif
        {
            for (int SC_idx=0; SC_idx<this->N_SCs; SC_idx++) {
                gsl_matrix* SC_gsl = gsl_matrix_alloc(this->nodes, this->nodes);
                for (int j = 0; j < this->nodes; j++) {
                    for (int k = 0; k < this->nodes; k++) {
                        // while copying transpose it from the shape (source, target) to (target, source)
                        // as this is the format expected by the FIC function
                        gsl_matrix_set(SC_gsl, j, k, SC[SC_idx][k*nodes + j]);
                    }
                }
                SCs_gsl.push_back(SC_gsl);
            }
        }
        gsl_vector * curr_w_IE = gsl_vector_alloc(this->nodes);
        double *curr_w_EE = (double *)malloc(this->nodes * sizeof(double));
        double *curr_w_EI = (double *)malloc(this->nodes * sizeof(double));
        for (int sim_idx=0; sim_idx<this->N_SIMS; sim_idx++) {
            // assign regional wEE and wEI
            // i.e., convert TVB-style parameters to
            // Demirtas et al. style parameters which
            // are used for the FIC
            // TODO: adapt the code in FIC to use TVB-style
            // parameters instead.
            for (int j=0; j<this->nodes; j++) {
                // w_EI = J_N
                curr_w_EI[j] = (double)(regional_params[1][sim_idx*this->nodes+j]);
                // w_EE = w_p * J_N
                curr_w_EE[j] = (double)(regional_params[0][sim_idx*this->nodes+j]) * curr_w_EI[j];
            }
            // do FIC for the current particle
            global_out_bool[0][sim_idx] = false;
            analytical_fic_het(
                SCs_gsl[SC_indices[sim_idx]], global_params[0][sim_idx], 
                curr_w_EE, curr_w_EI,
                curr_w_IE, global_out_bool[0]+sim_idx);
            if (global_out_bool[0][sim_idx]) {
                std::cerr << "In simulation #" << sim_idx << 
                    " analytical FIC failed. Setting wIE to 1 in all nodes" << std::endl;
                for (int j=0; j<this->nodes; j++) {
                    regional_params[2][sim_idx*this->nodes+j] = 1.0;
                }
            } else {
                // copy to w_IE_fic which will be passed on to the device
                for (int j=0; j<this->nodes; j++) {
                    regional_params[2][sim_idx*this->nodes+j] = (double)gsl_vector_get(curr_w_IE, j);
                }
            }
        }
        #ifdef OMP_ENABLED
        #pragma omp critical
        #endif
        {
            // free SCs_gsl and empty the vector
            for (auto &SC_gsl : SCs_gsl) {
                gsl_matrix_free(SC_gsl);
            }
            SCs_gsl.clear();
        }
    }

  _j_post_bw_step: |
    void rWWModel::_j_post_bw_step(
            double* _state_vars, double* _intermediate_vars,
            int* _ext_int, bool* _ext_bool, 
            int* _ext_int_shared, bool* _ext_bool_shared,
            bool& restart,
            double* _global_params, double* _regional_params,
            int& bw_i
            ) {
        if (_ext_bool_shared[0]) {
            if (((bw_i+1) >= this->conf.I_SAMPLING_START) & ((bw_i+1) <= this->conf.I_SAMPLING_END)) {
                _intermediate_vars[4] += _state_vars[0];
            }
            if ((bw_i+1) == this->conf.I_SAMPLING_END) {
                restart = false;
                _intermediate_vars[4] /= this->conf.I_SAMPLING_DURATION;
                _intermediate_vars[6] = _intermediate_vars[4] - rWWModel::mc.b_a_ratio_E;
                if (abs(_intermediate_vars[6] + 0.026) > 0.005) {
                    restart = true;
                    if (_ext_int_shared[0] < this->conf.max_fic_trials) { // only do the adjustment if max trials is not exceeded
                        // up- or downregulate inhibition
                        if ((_intermediate_vars[6]) < -0.026) {
                            _regional_params[2] -= _intermediate_vars[5];
                            _intermediate_vars[5] -= 0.001;
                            _intermediate_vars[5] = fmax(_intermediate_vars[5], 0.001);
                        } else {
                            _regional_params[2] += _intermediate_vars[5];
                        }
                    }
                }
            }
        }
    }

  h_post_bw_step: |
    void rWWModel::h_post_bw_step(double** _state_vars, double** _intermediate_vars,
            int** _ext_int, bool** _ext_bool, 
            int* _ext_int_shared, bool* _ext_bool_shared,
            bool& restart,
            double* _global_params, double** _regional_params,
            int& bw_i) {
        BaseModel::h_post_bw_step(
            _state_vars, _intermediate_vars, 
            _ext_int, _ext_bool, 
            _ext_int_shared, _ext_bool_shared,
            restart, 
            _global_params, _regional_params, 
            bw_i);
        // if needs_fic_adjustment in any node do another trial or declare fic failure and continue
        // the simulation until the end
        if ((_ext_bool_shared[0]) && ((bw_i+1) == this->conf.I_SAMPLING_END)) {
            if (restart) {
                if (_ext_int_shared[0] < (this->conf.max_fic_trials)) {
                    _ext_int_shared[0]++; // increment fic_trial
                } else {
                    // continue the simulation and
                    // declare FIC failed
                    restart = false;
                    _ext_bool_shared[0] = false; // _adjust_fic
                    _ext_bool_shared[1] = true; // fic_failed
                }
            } else {
                // if no node needs fic adjustment don't run
                // this block of code any more
                _ext_bool_shared[0] = false;
            }
        }
    }

  post_bw_step: |
    __device__ __NOINLINE__ void rWWModel::post_bw_step(
            double* _state_vars, double* _intermediate_vars,
            int* _ext_int, bool* _ext_bool, 
            int* _ext_int_shared, bool* _ext_bool_shared,
            bool& restart,
            double* _global_params, double* _regional_params,
            int& bw_i
            ) {
        if (_ext_bool_shared[0]) {
            if (((bw_i+1) >= this->conf.I_SAMPLING_START) & ((bw_i+1) <= this->conf.I_SAMPLING_END)) {
                _intermediate_vars[4] += _state_vars[0];
            }
            if ((bw_i+1) == this->conf.I_SAMPLING_END) {
                restart = false;
                __syncthreads(); // all threads must be at the same time point here given needs_fic_adjustment is shared
                _intermediate_vars[4] /= this->conf.I_SAMPLING_DURATION;
                _intermediate_vars[6] = _intermediate_vars[4] - d_rWWc.b_a_ratio_E;
                if (abs(_intermediate_vars[6] + 0.026) > 0.005) {
                    restart = true;
                    if (_ext_int_shared[0] < this->conf.max_fic_trials) { // only do the adjustment if max trials is not exceeded
                        // up- or downregulate inhibition
                        if ((_intermediate_vars[6]) < -0.026) {
                            _regional_params[2] -= _intermediate_vars[5];
                            _intermediate_vars[5] -= 0.001;
                            _intermediate_vars[5] = CUDA_MAX(_intermediate_vars[5], 0.001);
                        } else {
                            _regional_params[2] += _intermediate_vars[5];
                        }
                    }
                }
                __syncthreads(); // wait to see if needs_fic_adjustment in any node
                // if needs_fic_adjustment in any node do another trial or declare fic failure and continue
                // the simulation until the end
                if (restart) {
                    if (_ext_int_shared[0] < (this->conf.max_fic_trials)) {
                        if (threadIdx.x == 0) _ext_int_shared[0]++; // increment fic_trial
                    } else {
                        // continue the simulation and
                        // declare FIC failed
                        restart = false;
                        _ext_bool_shared[0] = false; // _adjust_fic
                        _ext_bool_shared[1] = true; // fic_failed
                    }
                } else {
                    // if no node needs fic adjustment don't run
                    // this block of code any more
                    _ext_bool_shared[0] = false;
                }
                __syncthreads();
            }
        }
    }

  h_post_integration: |
    void rWWModel::h_post_integration(
            double ***state_vars_out, 
            int **global_out_int, bool **global_out_bool,
            double* _state_vars, double* _intermediate_vars, 
            int* _ext_int, bool* _ext_bool, 
            int* _ext_int_shared, bool* _ext_bool_shared,
            double** global_params, double** regional_params,
            double* _global_params, double* _regional_params,
            int& sim_idx, const int& nodes, int& j
        ) {
        if (this->conf.do_fic) {
            // save the wIE adjustment results
            // modified wIE array
            regional_params[2][sim_idx*nodes+j] = _regional_params[2];
            if (j == 0) {
                // number of trials and fic failure
                global_out_int[0][sim_idx] = _ext_int_shared[0];
                global_out_bool[1][sim_idx] = _ext_bool_shared[1];
            }
        }
    }

  post_integration: |
    __device__ __NOINLINE__ void rWWModel::post_integration(
            double ***state_vars_out, 
            int **global_out_int, bool **global_out_bool,
            double* _state_vars, double* _intermediate_vars, 
            int* _ext_int, bool* _ext_bool,
            int* _ext_int_shared, bool* _ext_bool_shared,
            double** global_params, double** regional_params,
            double* _global_params, double* _regional_params,
            int& sim_idx, const int& nodes, int& j
        ) {
        if (this->conf.do_fic) {
            // save the wIE adjustment results
            // modified wIE array
            regional_params[2][sim_idx*nodes+j] = _regional_params[2];
            // number of trials and fic failure
            if (j == 0) {
                global_out_int[0][sim_idx] = _ext_int_shared[0];
                global_out_bool[1][sim_idx] = _ext_bool_shared[1];
            }
        }
    }

# Python class generation configuration
python_config:
  sel_state_var: r_E
  
  modifiable_params:
    - wIE
  
  exclude_configs:
    - I_SAMPLING_DURATION
  
  labels:
    G: 'G'
    w_p: '$w^{p}$'
    J_N: '$J^{N}$'
    wIE: '$w^{IE}$'
    sigma: '$\sigma$'
    I_E: '$I^E$'
    I_I: '$I^I$'
    r_E: '$r^E$'
    r_I: '$r^I$'
    S_E: '$S^E$'
    S_I: '$S^I$'
  
  custom_methods:
    N_setter: |
      @SimGroup.N.setter
      def N(self, N):
          super(rWWSimGroup, rWWSimGroup).N.__set__(self, N)
          if self.do_fic:
              self.param_lists["wIE"] = np.zeros((self._N, self.nodes), dtype=float)

    _process_out: |
      def _process_out(self, out):
          super()._process_out(out)
          if self.do_fic:
              # FIC stats
              self.fic_unstable = self._global_bools[0]
              self.fic_failed = self._global_bools[1]
              self.fic_ntrials = self._global_ints[0]
              # write FIC (+ numerical adjusted) wIE to param_lists
              self.param_lists["wIE"] = self._regional_params[2].reshape(self.N, -1)

    score: |
      def score(self, emp_fc_tril=None, emp_fcd_tril=None, emp_bold=None, **kwargs):
          """
          Calculates individual goodness-of-fit terms and aggregates them.
          In FIC models also calculates fic_penalty. Note that while 
          FIC penalty is included in the cost function of optimizer, 
          it is not included in the aggregate GOF.

          Parameters
          --------
          emp_fc_tril: :obj:`np.ndarray`
              1D array of empirical FC lower triangle. Shape: (edges,)
          emp_fcd_tril: :obj:`np.ndarray`
              1D array of empirical FCD lower triangle. Shape: (window_pairs,)
          emp_bold: :obj:`np.ndarray` or None
              cleaned and parcellated empirical BOLD time series. Shape: (nodes, volumes)
              Motion outliers should either be excluded (not recommended as it disrupts
              the temporal structure) or replaced with zeros.
              If provided emp_fc_tril and emp_fcd_tril will be ignored.
          **kwargs:
              keyword arguments passed to `cubnm.sim.SimGroup.score`

          Returns
          -------
          scores: :obj:`pd.DataFrame`
              The goodness of fit measures (columns) of each simulation (rows)
          """
          scores = super().score(emp_fc_tril, emp_fcd_tril, emp_bold, **kwargs)
          # calculate FIC penalty
          if self.do_fic & (self.fic_penalty_scale > 0):
              # calculate time-averaged r_E in each simulation-node
              if self.states_ts:
                  mean_r_E = self.sim_states["r_E"][:, self.n_states_samples_remove:].mean(axis=1)
              else:
                  mean_r_E = self.sim_states["r_E"]
              for idx in range(self.N):
                  # absolute deviation from target of 3 Hz
                  diff_r_E = np.abs(mean_r_E[idx, :] - 3)
                  if (diff_r_E > 1).sum() > 0:
                      # at least one node has a deviation greater than 1
                      # only consider deviations greater than 1
                      # in the penalty
                      diff_r_E[diff_r_E <= 1] = np.NaN
                      # within each node the FIC penalty decreases
                      # exponentially as the deviations gets smaller
                      # the penalty max value in each node is 1
                      # which is then scaled by fic_penalty_scale
                      # and averaged across nodes (with 0s/NaNs)
                      # in node with no deviation > 1 Hz
                      scores.loc[idx, "-fic_penalty"] = (
                          -np.nansum(1 - np.exp(-0.05 * (diff_r_E - 1)))
                          * self.fic_penalty_scale / self.nodes
                      )
                  else:
                      scores.loc[idx, "-fic_penalty"] = 0
          return scores

    _get_save_data: |
      def _get_save_data(self):
          """
          Get the simulation outputs and parameters to be saved to disk

          Returns
          -------
          out_data: :obj:`dict`
              dictionary of simulation outputs and parameters
          """
          out_data = super()._get_save_data()
          if self.do_fic:
              out_data.update(
                  fic_unstable=self.fic_unstable,
                  fic_failed=self.fic_failed,
                  fic_ntrials=self.fic_ntrials,
              )
          return out_data

    _problem_init: |
      def _problem_init(self, problem):
          """
          Extends BNMProblem initialization and includes FIC penalty
          if indicated.

          Parameters
          ----------
          problem: :obj:`cubnm.optimize.BNMProblem`
              optimization problem object
          """
          if (self.do_fic) & ("wIE" in problem.het_params):
              raise ValueError(
                  "In rWW wIE should not be specified as a heterogeneous parameter when FIC is done"
              )
          if problem.multiobj:
              if self.do_fic & (self.fic_penalty_scale > 0):
                  problem.obj_names.append("-fic_penalty")
                  problem.n_obj += 1

    _problem_evaluate: |
      def _problem_evaluate(self, problem, X, out, *args, **kwargs):
          """
          Extends BNMProblem evaluation and includes FIC penalty
          in the cost function if indicated.

          Parameters
          ----------
          X: :obj:`np.ndarray`
              the normalized parameters of current population in range [0, 1]. 
              Shape: (N, ndim)
          out: :obj:`dict`
              the output dictionary to store the results with keys ``'F'`` and ``'G'``.
              Currently only ``'F'`` (cost) is used.
          *args, **kwargs
          """
          # Note: scores (inidividual GOF measures) is passed on in kwargs 
          # in the internal mechanism of pymoo evaluation function
          scores = kwargs["scores"][-1]
          if self.do_fic & (self.fic_penalty_scale > 0):
              if problem.multiobj:
                  out["F"] = np.concatenate(
                      [out["F"], -scores.loc[:, ["-fic_penalty"]].values], axis=1
                  )
              else:
                  out["F"] -= scores.loc[:, "-fic_penalty"].values
    _get_test_configs: |
      @classmethod
      def _get_test_configs(cls, cpu_gpu_identity=False):
          """
          Get configs for testing the simulations

          Parameters
          ----------
          cpu_gpu_identity: :obj:`bool`
              indicates whether configs are for CPU/GPU identity tests
              in which case force_cpu is not included in the configs
              since tests will be done on both CPU and GPU

          Returns
          -------
          configs: :obj:`dict` of :obj:`list`
          """
          configs = super()._get_test_configs(cpu_gpu_identity)
          configs.update({
              # 0: no FIC
              # 1: analytical FIC
              # 2: analytical + numerical FIC
              'do_fic': [0, 1, 2]
          })
          return configs

    _get_test_instance: |
      @classmethod
      def _get_test_instance(cls, opts):
          """
          Initializes an instance that is used in tests

          Parameters
          ----------
          opts: :obj:`dict`
              dictionary of test options

          Returns
          -------
          sim_group: :obj:`cubnm.sim.rWWSimGroup`
              simulation group object of the test simulation
              which is not run yet
          """
          # initialze sim group
          sim_group = super()._get_test_instance(opts)
          # set do_fic
          sim_group.do_fic = opts['do_fic'] > 0
          if opts['do_fic'] == 2:
              sim_group.max_fic_trials = 5
          return sim_group